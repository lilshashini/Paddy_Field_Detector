# -*- coding: utf-8 -*-
"""python_script_SF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17jkfTumKYHua788EGOBIhJnKlRzVCy8o
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install git+https://github.com/facebookresearch/detectron2.git

import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
import json
import random
import torch

from detectron2.engine import DefaultPredictor
from detectron2.config import get_cfg
from detectron2.data import MetadataCatalog
from detectron2 import model_zoo

# --- Configuration ---
class DatasetConfig:
    OUTPUT_DIR = "./output"
    RESULTS_DIR = "./output/results"
    NUM_CLASSES = 1  # for shrimp farms

# --- Utility Functions ---

def get_detectron2_config():
    cfg = get_cfg()
    cfg.merge_from_file(model_zoo.get_config_file("COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml"))
    cfg.MODEL.ROI_HEADS.NUM_CLASSES = DatasetConfig.NUM_CLASSES
    cfg.MODEL.WEIGHTS = "/content/model_final.pth"
    cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.5
    cfg.MODEL.DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
    return cfg

def extract_polygons_from_mask(mask, class_id=None, min_area=100):
    if class_id is not None:
        binary_mask = (mask == class_id).astype(np.uint8)
    else:
        binary_mask = mask.astype(np.uint8)

    contours, _ = cv2.findContours(binary_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    polygons = []

    for contour in contours:
        if cv2.contourArea(contour) > min_area:
            epsilon = 0.02 * cv2.arcLength(contour, True)
            approx = cv2.approxPolyDP(contour, epsilon, True)
            polygon = approx.reshape(-1, 2).tolist()
            polygons.append(polygon)
    return polygons

def draw_polygons_on_image(image, polygons, colors=None, thickness=3, fill_alpha=0.3):
    image_with_polygons = image.copy()
    overlay = image.copy()
    if colors is None:
        colors = [(random.randint(0,255), random.randint(0,255), random.randint(0,255)) for _ in polygons]

    for i, polygon in enumerate(polygons):
        if len(polygon) < 3:
            continue
        pts = np.array(polygon, np.int32).reshape((-1, 1, 2))
        color = colors[i % len(colors)]
        cv2.fillPoly(overlay, [pts], color)
        cv2.polylines(image_with_polygons, [pts], True, color, thickness)
        center_x = int(np.mean([p[0][0] for p in pts]))
        center_y = int(np.mean([p[0][1] for p in pts]))
        cv2.putText(image_with_polygons, f'Farm {i+1}', (center_x-20, center_y),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
    return cv2.addWeighted(image_with_polygons, 1-fill_alpha, overlay, fill_alpha, 0)

def visualize_detection_results(image, mask, polygons, save_path=None):
    fig, axes = plt.subplots(2, 2, figsize=(20, 16))

    axes[0, 0].imshow(image)
    axes[0, 0].set_title('Original Image')
    axes[0, 0].axis('off')

    axes[0, 1].imshow(mask, cmap='viridis')
    axes[0, 1].set_title('Segmentation Mask')
    axes[0, 1].axis('off')

    image_with_outlines = image.copy()
    colors = plt.cm.Set3(np.linspace(0, 1, len(polygons)))[:, :3] * 255
    colors = [tuple(map(int, color)) for color in colors]

    for i, polygon in enumerate(polygons):
        if len(polygon) >= 3:
            pts = np.array(polygon, np.int32)
            cv2.polylines(image_with_outlines, [pts], True, colors[i], 4)

    axes[1, 0].imshow(image_with_outlines)
    axes[1, 0].set_title(f'Detected Polygons - {len(polygons)} farms')
    axes[1, 0].axis('off')

    image_with_filled = draw_polygons_on_image(image, polygons, colors, thickness=4, fill_alpha=0.4)
    axes[1, 1].imshow(image_with_filled)
    axes[1, 1].set_title(f'Shrimp Farms with Filled Polygons - {len(polygons)} farms')
    axes[1, 1].axis('off')

    total_area = sum([cv2.contourArea(np.array(p, dtype=np.int32)) for p in polygons])
    avg_points = np.mean([len(p) for p in polygons]) if polygons else 0

    stats_text = f"""Detection Statistics:
    ‚Ä¢ Total Farms Detected: {len(polygons)}
    ‚Ä¢ Average Points per Polygon: {avg_points:.1f}
    ‚Ä¢ Total Farm Area: {total_area:.0f} pixels"""
    fig.text(0.02, 0.02, stats_text, fontsize=12,
             bbox=dict(boxstyle="round,pad=0.5", facecolor="lightblue"))

    plt.tight_layout()
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')
    plt.show()

# --- Inference Function ---

def run_inference_on_image(image_path):
    os.makedirs(DatasetConfig.RESULTS_DIR, exist_ok=True)

    cfg = get_detectron2_config()
    predictor = DefaultPredictor(cfg)

    image = cv2.imread(image_path)
    if image is None:
        print(f"‚ùå Error loading image: {image_path}")
        return

    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    outputs = predictor(image)

    polygons = []
    if len(outputs["instances"]) > 0:
        masks = outputs["instances"].pred_masks.cpu().numpy()

        for i, mask in enumerate(masks):
            polygons += extract_polygons_from_mask(mask.astype(np.uint8))

        combined_mask = np.zeros_like(masks[0], dtype=np.uint8)
        for i, mask in enumerate(masks):
            combined_mask[mask] = i + 1
    else:
        combined_mask = np.zeros(image.shape[:2], dtype=np.uint8)

    base_name = os.path.splitext(os.path.basename(image_path))[0]
    output_vis_path = os.path.join(DatasetConfig.RESULTS_DIR, f"{base_name}_visualization.png")
    output_simple_path = os.path.join(DatasetConfig.RESULTS_DIR, f"{base_name}_polygon_overlay.png")
    output_json_path = os.path.join(DatasetConfig.RESULTS_DIR, f"{base_name}_polygons.json")

    visualize_detection_results(image_rgb, combined_mask, polygons, output_vis_path)
    simple_overlay = draw_polygons_on_image(image_rgb, polygons, thickness=4, fill_alpha=0)
    cv2.imwrite(output_simple_path, cv2.cvtColor(simple_overlay, cv2.COLOR_RGB2BGR))

    polygon_data = {
        "image_path": image_path,
        "num_polygons": len(polygons),
        "total_area": sum([cv2.contourArea(np.array(p, dtype=np.int32)) for p in polygons]),
        "average_points_per_polygon": np.mean([len(p) for p in polygons]) if polygons else 0,
        "polygons": polygons
    }
    with open(output_json_path, "w") as f:
        json.dump(polygon_data, f, indent=2)

    print(f"‚úÖ Processed: {image_path}")
    print(f"üìÅ Saved: {output_vis_path}, {output_simple_path}, {output_json_path}")

# --- Main ---

if __name__ == "__main__":
    test_image_path = "/content/drive/MyDrive/shrimp_test1/Shrimp_farm_detection.v2i.coco-segmentation-20250602T155727Z-1-001/Shrimp_farm_detection.v2i.coco-segmentation/valid/valid_img/SF22_png.rf.15e19b7496d5cce89c9f7cd5729eb4c4.jpg"  # üîÅ Replace with actual test image path
    run_inference_on_image(test_image_path)